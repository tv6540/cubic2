#!/bin/bash
set -e

LOG_FILE="$HOME/setup.log"

# Upload logs to dpaste on exit (success or failure) for diagnostics
# Ref: https://dpaste.com/api/
upload_logs() {
  echo -e "\n>>>> Uploading logs for diagnostics..."
  if [ ! -f "$LOG_FILE" ]; then
    echo "Log upload skipped: $LOG_FILE not found"
    return
  fi
  if ! command -v curl &>/dev/null; then
    echo "Log upload skipped: curl not available"
    return
  fi
  LOG_URL=$(curl -s --max-time 15 -F "content=<$LOG_FILE" -F "expiry_days=1" https://dpaste.com/api/v2/ 2>/dev/null)
  if [ -n "$LOG_URL" ]; then
    echo "Log URL: $LOG_URL" >> "$LOG_FILE"
    echo ""
    echo "============================================"
    echo "  SETUP LOG UPLOADED"
    echo "  $LOG_URL"
    echo "============================================"
    echo ""
    echo "Terminal will close in 10 minutes..."
    echo "(Press Ctrl+C to close now)"
    sleep 600
  else
    echo "Log upload failed (dpaste unreachable or timeout)"
    echo "Local log available at: $LOG_FILE"
    sleep 60
  fi
}
trap upload_logs EXIT

# Launch Chrome in background (called after install, before VLC)
launch_chrome() {
  if command -v google-chrome-stable &>/dev/null; then
    echo -e "\n>>>> Launching Chrome..."
    systemd-run --user --no-block \
      --setenv=DISPLAY="$DISPLAY" \
      --setenv=DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
      google-chrome-stable \
      --no-first-run \
      --no-default-browser-check \
      --disable-session-crashed-bubble \
      --start-maximized \
      "https://accounts.google.com/AccountChooser?Email=anandchakru.forum@gmail.com&continue=https://mail.google.com/"
    echo "Chrome launched via systemd"
  else
    echo "ERROR: Chrome not found after installation!"
  fi
}

# Kill gnome-initial-setup if somehow still running (should be disabled at build time)
echo -e "\n>>>> Ensuring gnome-initial-setup is stopped"
pkill -f gnome-initial-setup 2>/dev/null || true

echo -e "\n>>>> Mounting internal drives"
# Mount all internal drives (exclude USB/removable and live USB at /cdrom)
# Wrapped in subshell to ensure errors don't stop setup
FIRST_MOUNT=""
(
  set +e  # Disable exit-on-error for this section
  while read -r dev; do
    # Skip if no device found
    [ -z "$dev" ] && continue

    # Get device info
    devpath="/dev/$dev"

    # Skip if already mounted
    if mount | grep -q "^$devpath" 2>/dev/null; then
      mountpoint=$(mount | grep "^$devpath" 2>/dev/null | awk '{print $3}')
      echo "  $dev already mounted at $mountpoint"
      [ -z "$FIRST_MOUNT" ] && echo "$mountpoint" > /tmp/.first_mount
      continue
    fi

    # Mount using udisksctl (handles permissions properly)
    echo "  Mounting $dev..."
    if mountpoint=$(udisksctl mount -b "$devpath" 2>/dev/null | grep -oP "at \K/.*"); then
      echo "    Mounted at $mountpoint"
      [ ! -f /tmp/.first_mount ] && echo "$mountpoint" > /tmp/.first_mount
    else
      echo "    Warning: Could not mount $dev (continuing...)"
    fi
  done < <(lsblk -rno NAME,TYPE,RM,MOUNTPOINT 2>/dev/null | awk '$2=="part" && $3=="0" && $4=="" {print $1}')
) || echo "Warning: Drive mounting encountered errors (continuing...)"

# Read first mount from temp file (set in subshell)
if [ -f /tmp/.first_mount ]; then
  FIRST_MOUNT=$(cat /tmp/.first_mount 2>/dev/null)
  rm -f /tmp/.first_mount
fi

if [ -n "$FIRST_MOUNT" ]; then
  echo "First internal drive mounted at: $FIRST_MOUNT"
  # Create downloads directory on internal drive
  DOWNLOAD_DIR="$FIRST_MOUNT/Downloads"
  if mkdir -p "$DOWNLOAD_DIR" 2>/dev/null; then
    echo "Created $DOWNLOAD_DIR"
  else
    echo "Warning: Could not create $DOWNLOAD_DIR (continuing...)"
    DOWNLOAD_DIR=""
  fi
else
  echo "No internal drives found to mount (continuing...)"
  DOWNLOAD_DIR=""
fi

echo -e "\n>>>> Activating wired ethernet"
activate_ethernet() {
  local dev conn attempt

  dev=$(nmcli -t -f DEVICE,TYPE device 2>/dev/null | grep ':ethernet' | cut -d: -f1 | head -1)
  [ -z "$dev" ] && { echo "No ethernet device"; return 1; }

  echo "Found: $dev"

  # Try up to 3 times with NM restart
  for attempt in 1 2 3; do
    echo "Attempt $attempt/3..."

    # Try direct connect
    if nmcli device connect "$dev" 2>/dev/null; then
      echo "Connected!"
      return 0
    fi

    # Try connection profile
    conn=$(nmcli -t -f NAME,TYPE connection show 2>/dev/null | grep ':.*ethernet' | cut -d: -f1 | head -1)
    if [ -n "$conn" ] && nmcli connection up "$conn" 2>/dev/null; then
      echo "Connected!"
      return 0
    fi

    # Restart NM and retry (except on last attempt)
    if [ $attempt -lt 3 ]; then
      echo "Restarting NetworkManager..."
      sudo systemctl restart NetworkManager
      sleep 3
    fi
  done

  echo "Ethernet failed: Could not connect after 3 attempts (nmcli device connect failed)"
  return 1
}
activate_ethernet || echo "Ethernet activation skipped (network already up from pre-setup)"

echo -e "\n>>>> Configuring displays"
configure_displays() {
  # Note: xrandr works on both X11 and Wayland (via XWayland) on Ubuntu 24.04
  local xrandr_out
  xrandr_out=$(xrandr --current 2>/dev/null) || { echo "Warning: xrandr not available"; return 1; }

  # Log initial display state for diagnostics
  echo "Initial display state:"
  echo "$xrandr_out" | grep -E "^[A-Za-z].*connected" || echo "  (no displays detected)"

  # Find connected external display (HDMI, DP, DisplayPort, VGA, DVI)
  # Pattern covers: HDMI-1, HDMI-A-1, DP-1, DisplayPort-1, VGA-1, DVI-I-1, etc.
  local external internal
  external=$(echo "$xrandr_out" | grep -E "^(HDMI|DP|DisplayPort|VGA|DVI)" | grep " connected" | head -1 | awk '{print $1}')

  # Find internal display (eDP, LVDS, DSI for tablets)
  internal=$(echo "$xrandr_out" | grep -E "^(eDP|LVDS|DSI)" | grep " connected" | head -1 | awk '{print $1}')

  echo "Detected: external=$external internal=$internal"

  if [ -n "$external" ]; then
    # Use 1600x900 for Intel Haswell HDMI - higher resolutions cause audio issues
    echo "Setting $external as primary at 1600x900 (Haswell HDMI audio fix)"
    if xrandr --output "$external" --primary --mode 1600x900 2>&1; then
      echo "  xrandr command succeeded"
    else
      echo "  Warning: 1600x900 failed, trying auto..."
      xrandr --output "$external" --primary --auto 2>&1 || echo "  auto also failed"
    fi

    # Verify external is now active
    local active_monitors
    active_monitors=$(xrandr --listactivemonitors 2>/dev/null)
    echo "Active monitors after setting primary:"
    echo "$active_monitors"

    if ! echo "$active_monitors" | grep -q "$external"; then
      echo "ERROR: $external not active after configuration!"
      return 1
    fi

    # Disable internal display - try synchronously first with retries
    if [ -n "$internal" ]; then
      echo "Disabling internal display ($internal)..."
      local attempt disabled=false
      for attempt in 1 2 3 4 5 6 7 8 9 10; do
        if ! xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; then
          echo "  Internal display disabled (attempt $attempt)"
          disabled=true
          break
        fi
        echo "  Attempt $attempt: disabling $internal..."
        xrandr --output "$internal" --off 2>&1 || true
        sleep 2
      done

      if [ "$disabled" = false ]; then
        # Disable failed - try mirroring as fallback (ensures Activities shows on TV)
        echo "  Internal display still active, trying mirror mode as fallback..."
        if xrandr --output "$internal" --same-as "$external" --auto 2>&1; then
          echo "  Mirror mode enabled ($internal mirrors $external)"
          echo "  Note: Both screens show same content now"
        else
          echo "  Mirror mode failed, spawning background daemon to keep trying disable..."
          (
            attempts=0
            max_attempts=100  # 100 * 3s = 5 minutes
            while xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; do
              # Try disable first
              if xrandr --output "$internal" --off 2>/dev/null; then
                sleep 1
                if ! xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; then
                  echo "Internal display ($internal) disabled by background daemon" >> "$LOG_FILE"
                  break
                fi
              fi
              # Try mirror as fallback
              xrandr --output "$internal" --same-as "$external" --auto 2>/dev/null && \
                echo "Mirror mode enabled by background daemon" >> "$LOG_FILE" && break
              attempts=$((attempts + 1))
              if [ $attempts -ge $max_attempts ]; then
                echo "Warning: Could not disable or mirror $internal after 5 minutes" >> "$LOG_FILE"
                break
              fi
              sleep 3
            done
          ) &
          disown
        fi
      fi
    fi

    # Final verification
    echo "Final display state:"
    xrandr --listactivemonitors 2>/dev/null || echo "  (could not list monitors)"
  else
    echo "No external display detected"
    # Ensure internal display is active as fallback
    if [ -n "$internal" ]; then
      echo "Keeping internal display ($internal) active"
      xrandr --output "$internal" --auto 2>/dev/null || echo "Warning: Failed to configure $internal"
    fi
    echo "Connected displays:"
    echo "$xrandr_out" | grep " connected" || echo "  (none detected)"
  fi
}
configure_displays || true  # Don't exit if display config fails

# Screen timeout handled in security section (5 min idle lock)
# Video players auto-inhibit screensaver during playback

echo -e "\n>>>> Setting random wallpaper"
shopt -s nullglob
WALLPAPERS=(/usr/share/backgrounds/custom/wp-*.jpg)
shopt -u nullglob
if [ ${#WALLPAPERS[@]} -gt 0 ]; then
  RANDOM_WP="${WALLPAPERS[RANDOM % ${#WALLPAPERS[@]}]}"
  if gsettings set org.gnome.desktop.background picture-uri "file://$RANDOM_WP" 2>/dev/null && \
     gsettings set org.gnome.desktop.background picture-uri-dark "file://$RANDOM_WP" 2>/dev/null && \
     gsettings set org.gnome.desktop.background picture-options "zoom" 2>/dev/null; then
    echo "Applied wallpaper: $RANDOM_WP"
  else
    echo "Warning: Failed to set wallpaper (gsettings error)"
  fi
else
  echo "Warning: No wallpapers found in /usr/share/backgrounds/custom/"
  ls -la /usr/share/backgrounds/custom/ 2>/dev/null || echo "Directory doesn't exist"
fi

echo -e "\n>>>> Ignoring lid switch"
if grep -q "HandleLidSwitch=ignore" /etc/systemd/logind.conf 2>/dev/null; then
  echo "Lid switch already configured"
else
  if echo "HandleLidSwitch=ignore" | sudo tee -a /etc/systemd/logind.conf >/dev/null; then
    echo "Lid switch set to ignore"
  else
    echo "Warning: Failed to configure lid switch"
  fi
fi

# Audio will be configured after pulseaudio-utils is installed (see below)

echo -e "\n>>>> Setting timezone to Pacific"
if sudo timedatectl set-timezone America/Los_Angeles; then
  echo "Timezone set to America/Los_Angeles"
else
  echo "Warning: Failed to set timezone"
fi

echo -e "\n>>>> Applying security updates and Chrome dependencies"
# Disable locale generation (wastes 30+ seconds during package installs)
sudo mv /usr/sbin/locale-gen /usr/sbin/locale-gen.bak 2>/dev/null || true
sudo ln -sf /bin/true /usr/sbin/locale-gen
sudo mv /usr/bin/localedef /usr/bin/localedef.bak 2>/dev/null || true
sudo ln -sf /bin/true /usr/bin/localedef

if sudo DEBIAN_FRONTEND=noninteractive apt-get update -qq; then
  echo "Package lists updated"
else
  echo "Warning: apt-get update failed (continuing anyway)"
fi
# Install pulseaudio-utils if not pre-installed in ISO
if ! command -v pactl &>/dev/null; then
  echo "Installing pulseaudio-utils..."
  sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq pulseaudio-utils 2>/dev/null || true
else
  echo "pulseaudio-utils already installed"
fi
# Security updates
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq --no-install-recommends --only-upgrade \
  dpkg gpgv libapparmor1 libblkid1 libmount1 \
  libpam-modules libpam-modules-bin libpango-1.0-0 libpangocairo-1.0-0 \
  libpng16-16t64 libsmartcols1 libsqlite3-0 libssl3t64 \
  libsystemd0 libudev1 libuuid1 libxml2 openssl uuid-runtime \
  libc6 libgtk-3-0t64 libgtk-4-1 libglib2.0-0t64 libnss3 libnspr4 \
  libatk1.0-0t64 libcups2t64 libdrm2 libxkbcommon0 libasound2t64 \
  2>/dev/null || true

echo -e "\n>>>> Installing Google Chrome"
cd /tmp
if wget -q -T 60 https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb; then
  echo "Chrome downloaded"
else
  echo "ERROR: Failed to download Chrome (wget timeout or network error)"
fi
if sudo dpkg -i google-chrome-stable_current_amd64.deb 2>/dev/null; then
  echo "Chrome installed"
else
  echo "Chrome dpkg failed, fixing dependencies..."
  sudo DEBIAN_FRONTEND=noninteractive apt-get install -f -y
fi
rm -f google-chrome-stable_current_amd64.deb

# Chrome sandbox works out of the box when installed via dpkg
# No modification needed - sandbox is properly configured

install_chrome_extension() {
  local ext_id="$1"
  local ext_name="$2"
  local pref_dir="/opt/google/chrome/extensions"
  local pref_file="$pref_dir/$ext_id.json"
  sudo mkdir -p "$pref_dir"
  echo '{"external_update_url":"https://clients2.google.com/service/update2/crx"}' | sudo tee "$pref_file" > /dev/null
  echo "Installed extension: $ext_name"
}

echo -e "\n>>>> Installing Chrome extensions"
install_chrome_extension "cfhdojbkjhnklbpkdaibdccddilifddb" "Adblock Plus"
install_chrome_extension "hmbnhhcgiecenbbkgdoaoafjpeaboine" "Autoskip for Youtubeâ„¢ Ads"

# Set Chrome download directory to internal drive (if mounted)
# Wrapped to ensure errors don't stop setup
if [ -n "$DOWNLOAD_DIR" ] && [ -d "$DOWNLOAD_DIR" ]; then
  echo -e "\n>>>> Setting Chrome download directory to $DOWNLOAD_DIR"
  (
    set +e  # Disable exit-on-error for this section
    if ! mkdir -p ~/.config/google-chrome/Default 2>/dev/null; then
      echo "Warning: Could not create Chrome config directory"
      exit 0
    fi
    # Create or update Preferences file with download directory
    PREFS_FILE="$HOME/.config/google-chrome/Default/Preferences"
    if [ -f "$PREFS_FILE" ]; then
      # Update existing preferences
      if command -v python3 &>/dev/null; then
        python3 -c "
import json
import sys
try:
    with open('$PREFS_FILE', 'r') as f:
        prefs = json.load(f)
except:
    prefs = {}
prefs.setdefault('download', {})['default_directory'] = '$DOWNLOAD_DIR'
with open('$PREFS_FILE', 'w') as f:
    json.dump(prefs, f)
print('Chrome download directory set')
" || echo "Warning: Could not update Chrome preferences"
      else
        echo "Warning: python3 not available for Chrome config"
      fi
    else
      # Create new preferences file
      if echo "{\"download\":{\"default_directory\":\"$DOWNLOAD_DIR\"}}" > "$PREFS_FILE" 2>/dev/null; then
        echo "Chrome download directory configured"
      else
        echo "Warning: Could not create Chrome preferences file"
      fi
    fi
  ) || echo "Warning: Chrome download config failed (continuing...)"
else
  echo "Skipping Chrome download directory (no internal drive mounted)"
fi

# Launch Chrome now so user doesn't wait for VLC install
launch_chrome || true

echo -e "\n>>>> Installing VLC"
if command -v vlc &>/dev/null; then
  echo "VLC already installed"
else
  if sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq vlc; then
    echo "VLC installed"
  else
    echo "Warning: VLC installation failed"
  fi
fi

echo -e "\n>>>> Setting HDMI audio output"
# Use pacmd like cubic v1 - this runs synchronously after pulseaudio-utils is installed
if command -v pactl &>/dev/null; then
  echo "Available audio sinks:"
  pactl list short sinks 2>/dev/null || echo "  (none listed)"

  # Get HDMI sink name (same approach as cubic v1)
  HDMI_SINK=$(pactl list short sinks 2>/dev/null | grep -i hdmi | head -1 | awk '{print $2}')

  if [ -n "$HDMI_SINK" ]; then
    echo "Found HDMI sink: $HDMI_SINK"

    # Log audio card info for diagnostics (helps debug choppy audio issues)
    echo "Audio card info:"
    pactl list short cards 2>/dev/null || echo "  (none)"

    # Set default sink (same as cubic v1)
    if pacmd set-default-sink "$HDMI_SINK" 2>/dev/null; then
      echo "HDMI audio set successfully"
    else
      echo "Warning: pacmd set-default-sink failed, trying pactl..."
      pactl set-default-sink "$HDMI_SINK" 2>/dev/null || echo "Warning: pactl also failed"
    fi
  else
    echo "Warning: No HDMI audio sink found"
    echo "Available sinks:"
    pactl list short sinks 2>/dev/null | head -5
  fi
else
  echo "Warning: pactl not available (pulseaudio-utils not installed?)"
fi

# Restore locale tools after all package installs
sudo rm -f /usr/sbin/locale-gen /usr/bin/localedef
sudo mv /usr/sbin/locale-gen.bak /usr/sbin/locale-gen 2>/dev/null || true
sudo mv /usr/bin/localedef.bak /usr/bin/localedef 2>/dev/null || true

echo -e "\n>>>> Installing quick reset command (x)"
if sudo cp /tmp/cubic2/scripts/x /usr/bin/x && sudo chmod +x /usr/bin/x; then
  echo "Quick reset command installed: /usr/bin/x"
else
  echo "Warning: Failed to install quick reset command"
fi

echo -e "\n>>>> Setting dock favorites"
# Set favorites at runtime after Chrome/VLC are installed (not in ISO build)
# This prevents GNOME shell freeze when apps don't exist yet
if gsettings set org.gnome.shell favorite-apps "['google-chrome.desktop', 'vlc.desktop', 'org.gnome.Nautilus.desktop', 'org.gnome.Terminal.desktop']" 2>/dev/null; then
  echo "Dock favorites set"
else
  echo "Warning: Failed to set dock favorites (gsettings/dconf error)"
fi

echo -e "\n>>>> Hardening security"
# Enable firewall - deny all incoming, allow outgoing
if sudo ufw default deny incoming >/dev/null && \
   sudo ufw default allow outgoing >/dev/null && \
   sudo ufw --force enable >/dev/null; then
  echo "Firewall enabled (deny incoming, allow outgoing)"
else
  echo "Warning: Firewall configuration failed"
fi

# Disable SSH if present
if sudo systemctl disable ssh 2>/dev/null && sudo systemctl stop ssh 2>/dev/null; then
  echo "SSH disabled"
else
  echo "SSH not present or already disabled"
fi

# Disable Bluetooth (attack surface)
if sudo systemctl disable bluetooth 2>/dev/null && sudo systemctl stop bluetooth 2>/dev/null; then
  echo "Bluetooth disabled"
else
  echo "Bluetooth not present or already disabled"
fi

# Remount USB as read-only to prevent malware persistence
USB_DEVICE=$(mount | grep /cdrom | awk '{print $1}')
if [ -n "$USB_DEVICE" ]; then
  if sudo mount -o remount,ro /cdrom 2>/dev/null; then
    echo "USB remounted read-only"
  else
    echo "Warning: Failed to remount USB as read-only"
  fi
else
  echo "No USB mount point found at /cdrom"
fi

# Disable fwupd to prevent firmware modifications
if sudo systemctl mask fwupd >/dev/null 2>&1; then
  echo "Firmware updates disabled (fwupd masked)"
else
  echo "Warning: Failed to mask fwupd"
fi

echo -e "\n>>>> Cleaning up"
rm -rf /tmp/cubic2

echo -e "\n>>>> Setup complete!"
echo -e "    Tip: Run 'x' anytime to reset display/audio settings."
echo -e "    Log: ~/setup.log"
echo "=== Setup finished at $(date) ==="

# Chrome already launched earlier (after install, before VLC)
# Script will now exit and trigger upload_logs via EXIT trap
