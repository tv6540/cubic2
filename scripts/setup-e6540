#!/bin/bash
set -e

LOG_FILE="$HOME/setup.log"

# Upload logs to dpaste on exit (success or failure) for diagnostics
# Ref: https://dpaste.com/api/
upload_logs() {
  echo -e "\n>>>> Uploading logs for diagnostics..."
  if [ ! -f "$LOG_FILE" ]; then
    echo "Log upload skipped: $LOG_FILE not found"
    return
  fi
  if ! command -v curl &>/dev/null; then
    echo "Log upload skipped: curl not available"
    return
  fi
  LOG_URL=$(curl -s --max-time 15 -F "content=<$LOG_FILE" -F "expiry_days=1" https://dpaste.com/api/v2/ 2>/dev/null)
  if [ -n "$LOG_URL" ]; then
    echo "Log URL: $LOG_URL" >> "$LOG_FILE"
    echo ""
    echo "============================================"
    echo "  SETUP LOG UPLOADED"
    echo "  $LOG_URL"
    echo "============================================"
    echo ""
    echo "Terminal will close in 10 minutes..."
    echo "(Press Ctrl+C to close now)"
    sleep 600
  else
    echo "Log upload failed (dpaste unreachable or timeout)"
    echo "Local log available at: $LOG_FILE"
    sleep 60
  fi
}
trap upload_logs EXIT

# Launch Chrome in background (called after install, before VLC)
launch_chrome() {
  if command -v google-chrome-stable &>/dev/null; then
    echo -e "\n>>>> Launching Chrome..."
    systemd-run --user --no-block \
      --setenv=DISPLAY="$DISPLAY" \
      --setenv=DBUS_SESSION_BUS_ADDRESS="$DBUS_SESSION_BUS_ADDRESS" \
      google-chrome-stable \
      --no-first-run \
      --no-default-browser-check \
      --disable-session-crashed-bubble \
      --no-sandbox \
      --start-fullscreen \
      "https://accounts.google.com/AccountChooser?Email=anandchakru.forum@gmail.com&continue=https://mail.google.com/"
    echo "Chrome launched via systemd"
  else
    echo "ERROR: Chrome not found after installation!"
  fi
}

# Kill gnome-initial-setup if somehow still running (should be disabled at build time)
echo -e "\n>>>> Ensuring gnome-initial-setup is stopped"
pkill -f gnome-initial-setup 2>/dev/null || true

echo -e "\n>>>> Activating wired ethernet"
activate_ethernet() {
  local dev conn attempt

  dev=$(nmcli -t -f DEVICE,TYPE device 2>/dev/null | grep ':ethernet' | cut -d: -f1 | head -1)
  [ -z "$dev" ] && { echo "No ethernet device"; return 1; }

  echo "Found: $dev"

  # Try up to 3 times with NM restart
  for attempt in 1 2 3; do
    echo "Attempt $attempt/3..."

    # Try direct connect
    if nmcli device connect "$dev" 2>/dev/null; then
      echo "Connected!"
      return 0
    fi

    # Try connection profile
    conn=$(nmcli -t -f NAME,TYPE connection show 2>/dev/null | grep ':.*ethernet' | cut -d: -f1 | head -1)
    if [ -n "$conn" ] && nmcli connection up "$conn" 2>/dev/null; then
      echo "Connected!"
      return 0
    fi

    # Restart NM and retry (except on last attempt)
    if [ $attempt -lt 3 ]; then
      echo "Restarting NetworkManager..."
      sudo systemctl restart NetworkManager
      sleep 3
    fi
  done

  echo "Ethernet failed: Could not connect after 3 attempts (nmcli device connect failed)"
  return 1
}
activate_ethernet || echo "Ethernet activation skipped (network already up from pre-setup)"

echo -e "\n>>>> Configuring displays"
configure_displays() {
  # Note: xrandr works on both X11 and Wayland (via XWayland) on Ubuntu 24.04
  local xrandr_out
  xrandr_out=$(xrandr --current 2>/dev/null) || { echo "Warning: xrandr not available"; return 1; }

  # Log initial display state for diagnostics
  echo "Initial display state:"
  echo "$xrandr_out" | grep -E "^[A-Za-z].*connected" || echo "  (no displays detected)"

  # Find connected external display (HDMI, DP, DisplayPort, VGA, DVI)
  # Pattern covers: HDMI-1, HDMI-A-1, DP-1, DisplayPort-1, VGA-1, DVI-I-1, etc.
  local external internal
  external=$(echo "$xrandr_out" | grep -E "^(HDMI|DP|DisplayPort|VGA|DVI)" | grep " connected" | head -1 | awk '{print $1}')

  # Find internal display (eDP, LVDS, DSI for tablets)
  internal=$(echo "$xrandr_out" | grep -E "^(eDP|LVDS|DSI)" | grep " connected" | head -1 | awk '{print $1}')

  echo "Detected: external=$external internal=$internal"

  if [ -n "$external" ]; then
    # Get preferred resolution (marked with + or * in xrandr output)
    local preferred_mode
    preferred_mode=$(echo "$xrandr_out" | awk -v ext="$external" '
      $1 == ext { found=1; next }
      found && /^[A-Za-z]/ { exit }
      found && /[0-9]+x[0-9]+/ && /\+|\*/ { print $1; exit }
    ')

    # Configure external display
    if [ -n "$preferred_mode" ]; then
      echo "Setting $external as primary at $preferred_mode"
      if xrandr --output "$external" --primary --mode "$preferred_mode" 2>&1; then
        echo "  xrandr command succeeded"
      else
        echo "  Warning: Failed to set $preferred_mode, trying auto..."
        xrandr --output "$external" --primary --auto 2>&1 || echo "  auto also failed"
      fi
    else
      echo "Setting $external as primary (auto, no preferred mode found)"
      xrandr --output "$external" --primary --auto 2>&1 || echo "  Warning: auto failed"
    fi

    # Verify external is now active
    local active_monitors
    active_monitors=$(xrandr --listactivemonitors 2>/dev/null)
    echo "Active monitors after setting primary:"
    echo "$active_monitors"

    if ! echo "$active_monitors" | grep -q "$external"; then
      echo "ERROR: $external not active after configuration!"
      return 1
    fi

    # Disable internal display - try synchronously first with retries
    if [ -n "$internal" ]; then
      echo "Disabling internal display ($internal)..."
      local attempt disabled=false
      for attempt in 1 2 3 4 5 6 7 8 9 10; do
        if ! xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; then
          echo "  Internal display disabled (attempt $attempt)"
          disabled=true
          break
        fi
        echo "  Attempt $attempt: disabling $internal..."
        xrandr --output "$internal" --off 2>&1 || true
        sleep 2
      done

      if [ "$disabled" = false ]; then
        # Disable failed - try mirroring as fallback (ensures Activities shows on TV)
        echo "  Internal display still active, trying mirror mode as fallback..."
        if xrandr --output "$internal" --same-as "$external" --auto 2>&1; then
          echo "  Mirror mode enabled ($internal mirrors $external)"
          echo "  Note: Both screens show same content now"
        else
          echo "  Mirror mode failed, spawning background daemon to keep trying disable..."
          (
            attempts=0
            max_attempts=100  # 100 * 3s = 5 minutes
            while xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; do
              # Try disable first
              if xrandr --output "$internal" --off 2>/dev/null; then
                sleep 1
                if ! xrandr --listactivemonitors 2>/dev/null | grep -q "$internal"; then
                  echo "Internal display ($internal) disabled by background daemon" >> "$LOG_FILE"
                  break
                fi
              fi
              # Try mirror as fallback
              xrandr --output "$internal" --same-as "$external" --auto 2>/dev/null && \
                echo "Mirror mode enabled by background daemon" >> "$LOG_FILE" && break
              attempts=$((attempts + 1))
              if [ $attempts -ge $max_attempts ]; then
                echo "Warning: Could not disable or mirror $internal after 5 minutes" >> "$LOG_FILE"
                break
              fi
              sleep 3
            done
          ) &
          disown
        fi
      fi
    fi

    # Final verification
    echo "Final display state:"
    xrandr --listactivemonitors 2>/dev/null || echo "  (could not list monitors)"
  else
    echo "No external display detected"
    # Ensure internal display is active as fallback
    if [ -n "$internal" ]; then
      echo "Keeping internal display ($internal) active"
      xrandr --output "$internal" --auto 2>/dev/null || echo "Warning: Failed to configure $internal"
    fi
    echo "Connected displays:"
    echo "$xrandr_out" | grep " connected" || echo "  (none detected)"
  fi
}
configure_displays || true  # Don't exit if display config fails

# Screen timeout handled in security section (5 min idle lock)
# Video players auto-inhibit screensaver during playback

echo -e "\n>>>> Setting random wallpaper"
shopt -s nullglob
WALLPAPERS=(/usr/share/backgrounds/custom/wp-*.jpg)
shopt -u nullglob
if [ ${#WALLPAPERS[@]} -gt 0 ]; then
  RANDOM_WP="${WALLPAPERS[RANDOM % ${#WALLPAPERS[@]}]}"
  if gsettings set org.gnome.desktop.background picture-uri "file://$RANDOM_WP" 2>/dev/null && \
     gsettings set org.gnome.desktop.background picture-uri-dark "file://$RANDOM_WP" 2>/dev/null && \
     gsettings set org.gnome.desktop.background picture-options "zoom" 2>/dev/null; then
    echo "Applied wallpaper: $RANDOM_WP"
  else
    echo "Warning: Failed to set wallpaper (gsettings error)"
  fi
else
  echo "Warning: No wallpapers found in /usr/share/backgrounds/custom/"
  ls -la /usr/share/backgrounds/custom/ 2>/dev/null || echo "Directory doesn't exist"
fi

echo -e "\n>>>> Ignoring lid switch"
if grep -q "HandleLidSwitch=ignore" /etc/systemd/logind.conf 2>/dev/null; then
  echo "Lid switch already configured"
else
  if echo "HandleLidSwitch=ignore" | sudo tee -a /etc/systemd/logind.conf >/dev/null; then
    echo "Lid switch set to ignore"
  else
    echo "Warning: Failed to configure lid switch"
  fi
fi

# Audio will be configured after pulseaudio-utils is installed (see below)

echo -e "\n>>>> Setting timezone to Pacific"
if sudo timedatectl set-timezone America/Los_Angeles; then
  echo "Timezone set to America/Los_Angeles"
else
  echo "Warning: Failed to set timezone"
fi

echo -e "\n>>>> Applying security updates and Chrome dependencies"
# Disable locale generation (wastes 30+ seconds during package installs)
sudo mv /usr/sbin/locale-gen /usr/sbin/locale-gen.bak 2>/dev/null || true
sudo ln -sf /bin/true /usr/sbin/locale-gen
sudo mv /usr/bin/localedef /usr/bin/localedef.bak 2>/dev/null || true
sudo ln -sf /bin/true /usr/bin/localedef

if sudo DEBIAN_FRONTEND=noninteractive apt-get update -qq; then
  echo "Package lists updated"
else
  echo "Warning: apt-get update failed (continuing anyway)"
fi
# Install pulseaudio-utils if not pre-installed in ISO
if ! command -v pactl &>/dev/null; then
  echo "Installing pulseaudio-utils..."
  sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq pulseaudio-utils 2>/dev/null || true
else
  echo "pulseaudio-utils already installed"
fi
# Security updates
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq --no-install-recommends --only-upgrade \
  dpkg gpgv libapparmor1 libblkid1 libmount1 \
  libpam-modules libpam-modules-bin libpango-1.0-0 libpangocairo-1.0-0 \
  libpng16-16t64 libsmartcols1 libsqlite3-0 libssl3t64 \
  libsystemd0 libudev1 libuuid1 libxml2 openssl uuid-runtime \
  libc6 libgtk-3-0t64 libgtk-4-1 libglib2.0-0t64 libnss3 libnspr4 \
  libatk1.0-0t64 libcups2t64 libdrm2 libxkbcommon0 libasound2t64 \
  2>/dev/null || true

echo -e "\n>>>> Installing Google Chrome"
cd /tmp
if wget -q -T 60 https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb; then
  echo "Chrome downloaded"
else
  echo "ERROR: Failed to download Chrome (wget timeout or network error)"
fi
if sudo dpkg -i google-chrome-stable_current_amd64.deb 2>/dev/null; then
  echo "Chrome installed"
else
  echo "Chrome dpkg failed, fixing dependencies..."
  sudo DEBIAN_FRONTEND=noninteractive apt-get install -f -y
fi
rm -f google-chrome-stable_current_amd64.deb

# Chrome sandbox works out of the box when installed via dpkg
# No modification needed - sandbox is properly configured

install_chrome_extension() {
  local ext_id="$1"
  local ext_name="$2"
  local pref_dir="/opt/google/chrome/extensions"
  local pref_file="$pref_dir/$ext_id.json"
  sudo mkdir -p "$pref_dir"
  echo '{"external_update_url":"https://clients2.google.com/service/update2/crx"}' | sudo tee "$pref_file" > /dev/null
  echo "Installed extension: $ext_name"
}

echo -e "\n>>>> Installing Chrome extensions"
install_chrome_extension "cfhdojbkjhnklbpkdaibdccddilifddb" "Adblock Plus"
install_chrome_extension "hmbnhhcgiecenbbkgdoaoafjpeaboine" "Autoskip for Youtubeâ„¢ Ads"

# Launch Chrome now so user doesn't wait for VLC install
launch_chrome || true

echo -e "\n>>>> Installing VLC"
if command -v vlc &>/dev/null; then
  echo "VLC already installed"
else
  if sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq vlc; then
    echo "VLC installed"
  else
    echo "Warning: VLC installation failed"
  fi
fi

echo -e "\n>>>> Setting HDMI audio output"
# Use pacmd like cubic v1 - this runs synchronously after pulseaudio-utils is installed
if command -v pactl &>/dev/null; then
  echo "Available audio sinks:"
  pactl list short sinks 2>/dev/null || echo "  (none listed)"

  # Get HDMI sink name (same approach as cubic v1)
  HDMI_SINK=$(pactl list short sinks 2>/dev/null | grep -i hdmi | head -1 | awk '{print $2}')

  if [ -n "$HDMI_SINK" ]; then
    echo "Found HDMI sink: $HDMI_SINK"

    # Log audio card info for diagnostics (helps debug choppy audio issues)
    echo "Audio card info:"
    pactl list short cards 2>/dev/null || echo "  (none)"

    # Set default sink (same as cubic v1)
    if pacmd set-default-sink "$HDMI_SINK" 2>/dev/null; then
      echo "HDMI audio set successfully"
    else
      echo "Warning: pacmd set-default-sink failed, trying pactl..."
      pactl set-default-sink "$HDMI_SINK" 2>/dev/null || echo "Warning: pactl also failed"
    fi
  else
    echo "Warning: No HDMI audio sink found"
    echo "Available sinks:"
    pactl list short sinks 2>/dev/null | head -5
  fi
else
  echo "Warning: pactl not available (pulseaudio-utils not installed?)"
fi

# Restore locale tools after all package installs
sudo rm -f /usr/sbin/locale-gen /usr/bin/localedef
sudo mv /usr/sbin/locale-gen.bak /usr/sbin/locale-gen 2>/dev/null || true
sudo mv /usr/bin/localedef.bak /usr/bin/localedef 2>/dev/null || true

echo -e "\n>>>> Installing quick reset command (x)"
if sudo cp /tmp/cubic2/scripts/x /usr/bin/x && sudo chmod +x /usr/bin/x; then
  echo "Quick reset command installed: /usr/bin/x"
else
  echo "Warning: Failed to install quick reset command"
fi

echo -e "\n>>>> Setting dock favorites"
# Set favorites at runtime after Chrome/VLC are installed (not in ISO build)
# This prevents GNOME shell freeze when apps don't exist yet
if gsettings set org.gnome.shell favorite-apps "['google-chrome.desktop', 'vlc.desktop', 'org.gnome.Nautilus.desktop', 'org.gnome.Terminal.desktop']" 2>/dev/null; then
  echo "Dock favorites set"
else
  echo "Warning: Failed to set dock favorites (gsettings/dconf error)"
fi

echo -e "\n>>>> Hardening security"
# Enable firewall - deny all incoming, allow outgoing
if sudo ufw default deny incoming >/dev/null && \
   sudo ufw default allow outgoing >/dev/null && \
   sudo ufw --force enable >/dev/null; then
  echo "Firewall enabled (deny incoming, allow outgoing)"
else
  echo "Warning: Firewall configuration failed"
fi

# Disable SSH if present
if sudo systemctl disable ssh 2>/dev/null && sudo systemctl stop ssh 2>/dev/null; then
  echo "SSH disabled"
else
  echo "SSH not present or already disabled"
fi

# Disable Bluetooth (attack surface)
if sudo systemctl disable bluetooth 2>/dev/null && sudo systemctl stop bluetooth 2>/dev/null; then
  echo "Bluetooth disabled"
else
  echo "Bluetooth not present or already disabled"
fi

# Remount USB as read-only to prevent malware persistence
USB_DEVICE=$(mount | grep /cdrom | awk '{print $1}')
if [ -n "$USB_DEVICE" ]; then
  if sudo mount -o remount,ro /cdrom 2>/dev/null; then
    echo "USB remounted read-only"
  else
    echo "Warning: Failed to remount USB as read-only"
  fi
else
  echo "No USB mount point found at /cdrom"
fi

# Disable fwupd to prevent firmware modifications
if sudo systemctl mask fwupd >/dev/null 2>&1; then
  echo "Firmware updates disabled (fwupd masked)"
else
  echo "Warning: Failed to mask fwupd"
fi

echo -e "\n>>>> Cleaning up"
rm -rf /tmp/cubic2

echo -e "\n>>>> Setup complete!"
echo -e "    Tip: Run 'x' anytime to reset display/audio settings."
echo -e "    Log: ~/setup.log"
echo "=== Setup finished at $(date) ==="

# Chrome already launched earlier (after install, before VLC)
# Script will now exit and trigger upload_logs via EXIT trap
